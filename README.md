## 设计模式

### 一、分类
- 创建型模式：  
   - 单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式
- 结构性模式：   
  - 适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模 式
- 行为型模式：
   - 模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模 式、解释器模式、状态模式、策略模式、职责链模式、访问者模式

 ---
 ### 二、创建模式详解
一、单例模式
- 核心作用：保证一个类只有一个实例，并且提供一个访问该实例的全局访问点。
- 应用场景： 
  - 在spring MVC框架/struts1框架中，控制器对象也是单例
  - 在Spring中，每个Bean默认就是单例的，这样做的优点是Spring容器可以管理 
  - 项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置文件数据，每次new一个对象去读取。
  - 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。 – 操作系统的文件系统，也是大的单例模式实现的具体例子，一个操作系统只能有一个文
  - 实现方式：饿汉式、懒汉式、双重检测锁式、静态内部类式、枚举单例
    
二、工厂模式
- 核心作用： 
  - 实例化对象，用工厂方法代替new操作
  - 将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实 现类解耦。
- 应用场景
  - JDK中Calendar的getInstance方法
  - JDBC中Connection对象的获取
  - Hibernate中SessionFactory创建Session
  - spring中IOC容器创建管理bean对象
  - XML解析时的DocumentBuilderFactory创建解析器对象
  - 反射中Class对象的newInstance()
- 实现方式：
  - 简单工厂模式
  - 工厂方法模式
  - 抽象工厂模式
-  "工厂方法模式"VS"抽象工厂模式"
   - 抽象工厂模式是工厂方法模式的泛化版，工厂方法模式是一种特殊的抽象工厂方法
   - 从产品等级结构和产品族角度来说，产品等级结构相同，但工厂方法模式的产品族为一个，而抽象工厂模式是多个

三、建造者模式
- 核心作用：
  - 它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。
- 应用场景
  - StringBuilder类的append方法 
  - SQL中的PreparedStatement 
  - JDOM中，DomBuilder、SAXBuilder
- "抽象工厂模式"VS"建造者模式"
  - 抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。
  
四、适配器模式
- 核心作用：
  -  将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原 本由于接口不兼容而不能一起工作的那些类可以在一起工作。 
- 应用场景：
  - 系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。
  - 想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。
- 实现方式：
  - 类的适配器模式
  - 对象的适配器模式
  - 接口的适配器模式
  
五、装饰模式
- 核心作用：
  - 动态地给一个对象添加额外的功能，比继承灵活 
- 应用场景：
  - IO中输入流和输出流的设计 
  - Swing包中图形界面构件功能 
  - Servlet API 中提供了一个request对象的Decorator设计模式的默认实 现类HttpServletRequestWrapper，HttpServletRequestWrapper 类，增强了request对象的功能。 
  - Struts2中，request，response,session对象的处理
六、代理模式
- 核心作用：
  - 通过代理，控制对对象的访问！ 可以详细控制访问某个（某类）对象的方法，在调用这个方法前做前置处理，调用这个方法后 做后置处理。
- 应用场景：
  - JDK动态代理
  - CGLIB动态代理
  - Spring的AOP